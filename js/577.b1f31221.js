"use strict";(self["webpackChunkconstellation"]=self["webpackChunkconstellation"]||[]).push([[577],{34577:function(t,e,r){r.r(e);var n=r(75956),o=r(36350),s=r(24141);e["default"]={modules:{transport:[n.x,o.C,s.I]}}},24141:function(t,e,r){r.d(e,{I:function(){return E}});var n=r(69860),o=r(76237),s=r(99086);const i=globalThis.fetch;globalThis.Headers,globalThis.Request,globalThis.Response;class a extends Error{constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}}function c(t){if(null!=t){if("function"===typeof t[Symbol.iterator])return t[Symbol.iterator]();if("function"===typeof t[Symbol.asyncIterator])return t[Symbol.asyncIterator]();if("function"===typeof t.next)return t}throw new Error("argument is not an iterator or iterable")}function l(t,e,r){const n=r??{},o=c(t);async function*s(){let r;const s=()=>{null!=r&&r()};e.addEventListener("abort",s);while(1){let c;try{if(e.aborted){const{abortMessage:t,abortCode:e}=n;throw new a(t,e)}const t=new Promise(((t,e)=>{r=()=>{const{abortMessage:t,abortCode:r}=n;e(new a(t,r))}}));c=await Promise.race([t,o.next()]),r=null}catch(i){e.removeEventListener("abort",s);const r="aborted"===i.type&&e.aborted;if(r&&null!=n.onAbort&&await n.onAbort(t),"function"===typeof o.return)try{const t=o.return();t instanceof Promise&&t.catch((t=>{null!=n.onReturnError&&n.onReturnError(t)}))}catch(i){null!=n.onReturnError&&n.onReturnError(i)}if(r&&!0===n.returnOnAbort)return;throw i}if(!0===c.done)break;yield c.value}e.removeEventListener("abort",s)}return s()}var u=r(92263),d=r(52217);const b=421,h=290,p=2e3,w=(0,n.kg)("libp2p:webrtc-direct:socket");function f(t,e){const{sink:r,source:n}=t,o={remoteAddr:e.remoteAddr,async sink(t){null!=e.signal&&(t=l(t,e.signal));try{await r(t)}catch(n){"aborted"!==n.type&&w.error(n)}},source:null!=e.signal?l(n,e.signal):n,timeline:{open:Date.now()},async close(){if(t.closed)return;const e=Date.now(),r=setTimeout((()=>{if(null!=o.remoteAddr){const{host:t,port:r}=o.remoteAddr.toOptions();w("timeout closing socket to %s:%s after %dms, destroying it manually",t,r,Date.now()-e)}t.closed||t.close().catch((t=>{w.error("could not close socket",t)}))}),p);try{await t.close()}finally{clearTimeout(r)}}};return t.addEventListener("close",(()=>{null==o.timeline.close&&(o.timeline.close=Date.now())}),{once:!0}),o}function m(){throw new Error("WebRTCDirect Servers can not be created in the browser!")}var y=r(96862),g=r(12348);const v=(0,n.kg)("libp2p:webrtc-direct");class E{constructor(t){this.initiatorOptions=t?.initiatorOptions,this.recieverOptions=t?.recieverOptions,this.wrtc=t?.wrtc}get[g.N](){return!0}get[Symbol.toStringTag](){return"@libp2p/webrtc-direct"}async dial(t,e){const r=await this._connect(t,e),n=f(r,{remoteAddr:t,signal:e.signal});v("new outbound connection %s",n.remoteAddr);const o=await e.upgrader.upgradeOutbound(n);return v("outbound connection %s upgraded",n.remoteAddr),o}async _connect(t,e){if(!0===e.signal?.aborted)throw new a;const r={initiator:!0,trickle:!1,...this.initiatorOptions};return null!=this.wrtc&&(r.wrtc=this.wrtc),await new Promise(((n,o)=>{let c;const l=t.toOptions();v("Dialing %s:%s",l.host,l.port);const b=new y.PD(r),h=t=>{const e=t.detail;if(!c){const t=`connection error ${l.host}:${l.port}: ${e.message}`;v.error(t),e.message=t,f(e)}},p=()=>{c=!0,v("connection opened %s:%s",l.host,l.port),f()},w=()=>{v.error("connection aborted %s:%s",l.host,l.port),b.close().finally((()=>{f(new a)}))},f=t=>{b.removeEventListener("error",h),b.removeEventListener("ready",p),e.signal?.removeEventListener("abort",w),null!=t?o(t):n(b)};b.addEventListener("error",h,{once:!0}),b.addEventListener("ready",p,{once:!0}),b.addEventListener("close",(()=>{b.removeEventListener("error",h)})),e.signal?.addEventListener("abort",w);const m=async t=>{if("offer"!==t.type)return;const e=JSON.stringify(t);let r=l.host;6!==l.family||r.startsWith("[")||(r=`[${r}]`);const n=`http://${r}:${l.port}`,a=`/?signal=${s.base58btc.encode((0,d.m)(e))}`,c=n+a;try{const t=await i(c),e=await t.text();if(""===e.trim())return;const r=s.base58btc.decode(e),n=(0,u.B)(r),o=JSON.parse(n);b.handleSignal(o)}catch(h){await b.close(h),o(h)}};b.addEventListener("signal",(t=>{const e=t.detail;m(e).catch((async t=>{await b.close(t)}))}))}))}createListener(t){return m({...t,receiverOptions:this.recieverOptions,wrtc:this.wrtc})}filter(t){return t=Array.isArray(t)?t:[t],t.filter((t=>!t.protoCodes().includes(h)&&o.Ih.matches(t.decapsulateCode(b))))}}}}]);